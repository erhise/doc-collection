{"data":{"site":{"siteMetadata":{"title":"My Collection of Markdowns","description":"This is my collection of various documentation."}},"markdownRemark":{"html":"<p>Big-O notation is a special notation that tells you how fast an algorithm is. It does not tell you how fast in seconds your algorithm will run to completion (<em>duh</em>, of course). Essentially, Big-O tells us the worst case scenario our algorithm will run at.</p>\n<p>Algorithms teach you that large problems can be broken down into smaller problems.\nHow can we write a maintainable solution that will scale efficiently?</p>\n<h3>Counter function</h3>\n<pre><code class=\"language-javascript\">function counter() {\n    \n}\n</code></pre>\n<p>Using loop</p>\n<pre><code class=\"language-javascript\">function counter() {\n    for (let n=0; n&#x3C;=10; n++) {\n        console.log(n); // 0,1,2,3,4,5,6,7,8,9,10\n    }\n}\n</code></pre>\n<p>Recursion instead of a loop</p>\n<pre><code class=\"language-javascript\">function counter(n) {\n    console.log(n); // 0,1,2,3,4,5,6,7,8,9,10\n    if (n === 10) {\n        return;\n    }\n    return counter(n + 1);\n}\n</code></pre>\n<p>In recursion we need to have at least one <strong>base case</strong> and one <strong>recursion case</strong>, otherwise it's going to enter an infinite loop.</p>\n<p><em>Note</em>: there's no performance benefit to using recursion. In fact, loops are sometimes better for performance. Contrary, recursion can sometimes be easier to read/understand.</p>\n<h3>Example of recursive case</h3>\n<pre><code class=\"language-javascript\">const items = [[1,2,3],[4,5,6]];\n\nfunction findSix(i) {\n    let hasSix=\"no\";\n    i.forEach(a => {\n        a.forEach(l => {\n            if (l === 6) {\n                hasSix = \"yes\";\n            }\n        });\n    });\n    return hasSix;\n}\n</code></pre>\n<p>Solve it with recursion</p>\n<pre><code class=\"language-javascript\">const items = [[1,2,3],[4,5,[6]]]; // &#x3C;-- notice difference\n\nfunction findSix(i) {\n    let hasSix=\"no\";\n    i.forEach(a => {\n        if (l === 6) { // &#x3C;-- base case\n            hasSix = \"yes\";\n        }\n        if (Array.isArray(a)) { // &#x3C;-- recursion case\n            hasSix = findSix(a);\n        }\n    });\n    return hasSix;\n}\n</code></pre>\n<h3>Divide and Conquer function</h3>\n<p>Divide and conquer algorithms are recursive algorithms. It's a way to think about a problem. It is composed by using recursive functions to create a base case and to divide or decrease a problem until it becomes the base case.</p>\n<h4>Let's create a sum function</h4>\n<pre><code class=\"language-javascript\">function sum(arr) {\n    let total = 0;\n    for (let i of arr) {\n        total += i;\n    }\n    return total;\n}\n\nconsole.log(sum([1,2,3,4,5])); // 15\n</code></pre>\n<p>How to Divide and Conquer and recursion to break this down into smaller problems? Smallest case with our numbers would be if we had an array of just one number or even an empty array.</p>\n<pre><code class=\"language-javascript\">function sum(arr) {\n    if (arr.length === 0) return 0;\n}\n</code></pre>\n<p>Goal is to move closer to this with each recursive call.</p>\n<pre><code class=\"language-javascript\">function sum(arr) {\n    if (arr.length === 0) return 0;\n    return arr[0] + sum(arr.slice(1));\n}\n\n// 1 + sum([2,3,4,5])\n// 2 + sum([3,4,5])\n</code></pre>\n<h3>Selection Sort</h3>\n<blockquote>\n<p>Big-O notation: O(n x n) or O(n^2)</p>\n</blockquote>\n<p>Not the fastest sorting algorithm, but it get's the job done.</p>\n<pre><code class=\"language-javascript\">function findLargestValue(list) {\n    let lrg = list[0];\n    let indexOfLarge = 0;\n    for (let i; i &#x3C;= list.length; i++) {\n        if (lrg &#x3C; list[i]) {\n            lrg = list[i];\n            indexOfLarge = i;\n        }\n    }\n    return indexOfLarge;\n}\n\nfunction selectionSort(list) {\n    let newList = [];\n    let lrgItem;\n    while (list.length) {\n        lrgItem = findLargestValue(list);\n        newList.push(list[lrgItem]);\n        list.splice(lrgItem, 1);\n    }\n    return newList;\n}\n\nconst itemsToSort = [3,2,4,1,6];\nconsole.log(slectionSort(itemsToSort)); // [6,4,3,2,1]\n</code></pre>\n<ol>\n<li>Creating a new array. This is the array that is going to be returned with this function that we see printed in the console.log.</li>\n<li>Use while loop, where findLargestValue function gets called, passing in the current <code>list</code> that have been provided. Once this <code>findLargestValue</code> function returns, it gives the index location the current larget item.</li>\n<li>Which gets pushed onto this new array, then also gets removed right after that.</li>\n<li>New list gets returned.</li>\n</ol>\n<p>Because we need to call our <code>findLargestValue</code> function for N number of times, i.e. we have to call our function a total of however long our list is - this gives our <code>selectionSort</code> function a beginning big O notation of <code>O(n)</code>.</p>\n<p>Then if we remember our <code>findLargestValue</code> function also has a loop inside of it, i.e. stepping through another N times with its provided list, this makes our big O notation <code>O(n*n) or O(n^2)</code></p>\n<h3>QuickSort function</h3>\n<pre><code class=\"language-javascript\">function quickSort(array) {\n    if (array.length &#x3C; 2) return array;\n    const pivotIndex = Math.floor(array.length / 2);\n    const pivot = array[pivotIndex];\n    const less = [];\n    const greater = [];\n    for (const i in array) {\n        if (i != pivotIndex) {\n            array[i] > pivot\n                ? greater.push(array[i])\n                : less.push(array[i]);\n        }\n    }\n    return [\n        ...quickSort(less),\n        pivot,\n        ...quickSort(greater),\n    ];\n}\n\n// pivot: 5, 2, 4\n// n-times: 7  \nconsole.log(quickSort([6, 3, 4, 5, 2, 1])); // [1, 2, 3, 4, 5, 6]\n</code></pre>\n<p>Every single item in the array needs to be touched. We need to see how large or small an item is in order to know where it fits in line. We know we're at least going to be <code>O(n)</code>.</p>\n<pre><code>// O(n) * O(log n) = O(n log n) --> best and average case\n// O(n) * O(n) = O(n^2) --> worst case\n</code></pre>","excerpt":"Big-O notation is a special notation that tells you how fast an algorithm is. It does not tell you how fast in seconds your algorithm willâ€¦","fields":{"tagSlugs":["/tags/javascript","/tags/algorithms"]},"frontmatter":{"title":"Algorithms in JavaScript","tags":["javascript","algorithms"],"date":"2018-12-16"}}},"pageContext":{"slug":"/docs/algorithms-in-javascript/","prev":{"fields":{"slug":"/docs/gatsby/"},"frontmatter":{"title":"Thoughts about Gatsby","tags":["thougts","movie"]}},"next":{"fields":{"slug":"/docs/advanced-typescript/"},"frontmatter":{"title":"Advanced TypeScript","tags":["typescript","advanced"]}}}}